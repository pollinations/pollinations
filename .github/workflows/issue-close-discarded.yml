name: Issue Close Discarded

on:
  schedule:
    - cron: '0 * * * *'  # Run every hour
  workflow_dispatch:

jobs:
  close-discarded:
    if: github.repository == 'pollinations/pollinations'
    runs-on: ubuntu-latest
    steps:
      - name: Generate Pollinations AI Token
        id: pollinations-ai
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.POLLY_BOT_APP_ID }}
          private-key: ${{ secrets.POLLY_BOT_PRIVATE_KEY }}
          owner: pollinations

      - name: Close issues in "Discarded" column
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.pollinations-ai.outputs.token }}
          script: |
            const ORG = 'pollinations';
            const PROJECT_NUMBER = 20;
            
            // GraphQL query to get project items
            const query = `
              query($org: String!, $number: Int!) {
                organization(login: $org) {
                  projectV2(number: $number) {
                    items(first: 100) {
                      nodes {
                        id
                        fieldValues(first: 20) {
                          nodes {
                            ... on ProjectV2ItemFieldSingleSelectValue {
                              name
                              field {
                                ... on ProjectV2SingleSelectField {
                                  name
                                }
                              }
                            }
                          }
                        }
                        content {
                          ... on Issue {
                            id
                            number
                            state
                            title
                            repository {
                              name
                              owner {
                                login
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            `;

            try {
              const result = await github.graphql(query, {
                org: ORG,
                number: PROJECT_NUMBER
              });

              // Check if project data was returned
              if (!result.organization || !result.organization.projectV2) {
                 console.log('Project not found or accessible. Check PAT permissions.');
                 return;
              }

              const items = result.organization.projectV2.items.nodes;
              
              console.log(`Found ${items.length} items in Project #${PROJECT_NUMBER}`);

              for (const item of items) {
                // Skip if content is not an issue or not loaded
                if (!item.content || !item.content.number) continue;
                
                const issue = item.content;
                
                // Check if issue is OPEN
                if (issue.state !== 'OPEN') continue;

                // Check status field
                let status = null;
                for (const fieldValue of item.fieldValues.nodes) {
                  if (fieldValue.field && fieldValue.field.name === 'Status') {
                    status = fieldValue.name;
                    break;
                  }
                }

                if (status === 'Discarded') {
                  console.log(`Closing Issue #${issue.number} "${issue.title}" (Status: Discarded)`);
                  
                  // Close the issue
                  await github.rest.issues.update({
                    owner: issue.repository.owner.login,
                    repo: issue.repository.name,
                    issue_number: issue.number,
                    state: 'closed',
                    state_reason: 'not_planned'
                  });
                }
              }
            } catch (error) {
              console.error('Error querying project:', error);
              core.setFailed(error.message);
            }
