import debug from "debug";
import fetch from "node-fetch";

const log = debug("pollinations:transforms:imageUrl");
const errorLog = debug("pollinations:transforms:imageUrl:error");

const MIME_TYPES: Record<string, string> = {
    jpg: "image/jpeg",
    jpeg: "image/jpeg",
    png: "image/png",
    gif: "image/gif",
    webp: "image/webp",
    bmp: "image/bmp",
    svg: "image/svg+xml",
};

class ImageFetchError extends Error {
    status: number;
    url: string;

    constructor(message: string, statusCode: number, url: string) {
        super(message);
        this.name = "ImageFetchError";
        this.status = statusCode;
        this.url = url;
    }
}

/** Max image size: 20MB */
const MAX_IMAGE_SIZE = 20 * 1024 * 1024;

function detectMimeType(url: string, contentType: string | null): string {
    if (contentType?.startsWith("image/")) {
        return contentType.split(";")[0].trim();
    }

    try {
        const ext = new URL(url).pathname.split(".").pop()?.toLowerCase();
        if (ext && ext in MIME_TYPES) {
            return MIME_TYPES[ext];
        }
    } catch {
        // Invalid URL, skip
    }

    errorLog(`Could not detect MIME type for ${url}, defaulting to image/jpeg`);
    return "image/jpeg";
}

function buildErrorMessage(
    status: number,
    statusText: string,
    url: string,
): string {
    const base = `Failed to fetch image from ${url}: HTTP ${status} ${statusText || "Unknown error"}`;

    switch (status) {
        case 401:
        case 403:
            return `${base}. The image requires authentication or is forbidden. Please use a publicly accessible image URL.`;
        case 404:
            return `${base}. The image was not found. Please check the URL is correct.`;
        case 429:
            return `${base}. The image server is rate limiting requests. Please try a different image source or wait before retrying.`;
        default:
            return base;
    }
}

async function fetchImageAsBase64(url: string): Promise<string> {
    try {
        log(`Fetching image: ${url}`);
        const response = await fetch(url, {
            signal: AbortSignal.timeout(30000),
            headers: { "User-Agent": "Pollinations/1.0" },
        });

        if (!response.ok) {
            throw new ImageFetchError(
                buildErrorMessage(response.status, response.statusText, url),
                response.status,
                url,
            );
        }

        const contentType = response.headers.get("content-type");
        if (contentType && !contentType.startsWith("image/")) {
            throw new ImageFetchError(
                `Invalid content type for ${url}: received ${contentType}, expected image/*. Please provide a direct link to an image file.`,
                400,
                url,
            );
        }

        const contentLength = response.headers.get("content-length");
        if (contentLength && parseInt(contentLength, 10) > MAX_IMAGE_SIZE) {
            throw new ImageFetchError(
                `Image too large: ${contentLength} bytes (max ${MAX_IMAGE_SIZE} bytes). Please use a smaller image.`,
                400,
                url,
            );
        }

        const mimeType = detectMimeType(url, contentType);
        const arrayBuffer = await response.arrayBuffer();

        if (arrayBuffer.byteLength > MAX_IMAGE_SIZE) {
            throw new ImageFetchError(
                `Image too large: ${arrayBuffer.byteLength} bytes (max ${MAX_IMAGE_SIZE} bytes). Please use a smaller image.`,
                400,
                url,
            );
        }

        const base64 = Buffer.from(arrayBuffer).toString("base64");
        log(`Converted image to base64: ${mimeType}, ${base64.length} chars`);
        return `data:${mimeType};base64,${base64}`;
    } catch (error: any) {
        if (error instanceof ImageFetchError) {
            errorLog(`Image fetch error for ${url}: ${error.message}`);
            throw error;
        }

        let errorMessage = `Failed to fetch image from ${url}: ${error.message}`;

        if (error.name === "AbortError") {
            errorMessage = `Image fetch timeout for ${url}: The server took too long to respond (>30 seconds). Please try a faster image host.`;
        } else if (error.code === "ENOTFOUND") {
            errorMessage = `Invalid image URL ${url}: The domain could not be found. Please check the URL is correct.`;
        } else if (error.code === "ECONNREFUSED") {
            errorMessage = `Cannot connect to image server ${url}: Connection refused. The server may be down.`;
        }

        errorLog(`Failed to fetch image ${url}: ${error.message}`);
        throw new ImageFetchError(errorMessage, 400, url);
    }
}

/**
 * Returns true if the URL is an HTTP(S) URL that needs base64 conversion.
 * Data URLs and GCS URLs are already supported natively.
 */
function needsConversion(url: string | undefined): boolean {
    if (!url) return false;
    if (url.startsWith("data:")) return false;
    if (url.startsWith("gs://")) return false;
    return url.startsWith("http://") || url.startsWith("https://");
}

interface ContentPart {
    type: string;
    image_url?: { url: string; [key: string]: unknown };
    [key: string]: unknown;
}

async function processContentPart(part: ContentPart): Promise<ContentPart> {
    if (part.type !== "image_url" || !part.image_url?.url) {
        return part;
    }

    if (!needsConversion(part.image_url.url)) {
        return part;
    }

    const dataUrl = await fetchImageAsBase64(part.image_url.url);
    return {
        ...part,
        image_url: { ...part.image_url, url: dataUrl },
    };
}

async function processMessageContent(
    content: ContentPart[],
): Promise<ContentPart[]> {
    return Promise.all(content.map(processContentPart));
}

interface Message {
    content?: string | ContentPart[];
    [key: string]: unknown;
}

/**
 * Creates a transform that converts HTTP image URLs to base64 data URLs
 * for Vertex AI and Bedrock compatibility. These providers require base64
 * inline data rather than HTTP URLs.
 */
export function createImageUrlToBase64Transform() {
    return async (messages: Message[], options: Record<string, any>) => {
        const config = options?.modelConfig;
        const provider = config?.provider;
        const targets = config?.targets || [];
        const hasBase64Target = targets.some(
            (t: any) => t.provider === "vertex-ai" || t.provider === "bedrock",
        );

        if (
            provider !== "vertex-ai" &&
            provider !== "bedrock" &&
            !hasBase64Target
        ) {
            return { messages, options };
        }

        const providerInfo = provider
            ? provider
            : `fallback[${targets.map((t: any) => t.provider).join(", ")}]`;
        log(`Processing messages for ${providerInfo} image URL conversion`);

        const processedMessages = await Promise.all(
            messages.map(async (message) => {
                if (!message.content || typeof message.content === "string") {
                    return message;
                }

                const processedContent = await processMessageContent(
                    message.content,
                );
                return { ...message, content: processedContent };
            }),
        );

        log("Image URL conversion complete");
        return { messages: processedMessages, options };
    };
}
